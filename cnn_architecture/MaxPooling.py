import numpy as np

from cnn_architecture.BaseLayer import BaseLayer
from cnn_architecture.utils import column_convert_2_image, PADDING_VALID, image_convert_2_column

# Defining pool layer class
class PoolingLayer(BaseLayer):
    """ A class that is called after Convolution layer.It takes feature map as input and extract features from it.
    
    Attributes:
    ----------
    pool_shape_size: 2*2
        Defines filter size
    padding:
    we chose valid_padding
    Here we use non zero padding outside the edges when we do max pool.
    Stride=can be 1,2 or more.We chose 2
    The number of pixels shifts over the input matrix
    
    Methods:
    --------
    initialize_value(attributes):
    Takes in the particular parameter and initializes respective values for it.
    return_out():
    Return Number of channels,Height and Width of an image.
    forward_feed:
    The forward flow take the input from covolution layer and return the reduced features of the feature map generated by a convolution layer.
    backward_feed:
    Defines the backward flow from the output layer.it returns total gradient
    
    """ 
    def __init__(self, shape_of_pool=(2, 2), stride=2, type_of_padding=PADDING_VALID):
        self.type_of_padding = type_of_padding
        self.pool_size = shape_of_pool
        if stride is None:
            self.stride = shape_of_pool[0]
        else:
            self.stride = stride
    
    def backward_feed(self, gradient_sum):
        b_sz, _, _, _ = gradient_sum.shape
        channels, hi, wi = self.size_of_input
        gradient_sum = gradient_sum.transpose(2, 3, 0, 1).ravel()
        total_grad_col = self._backward_pooling(gradient_sum)
        gradient_sum = column_convert_2_image(total_grad_col, (b_sz * channels, 1, hi, wi), self.pool_size,
                                 self.stride, self.type_of_padding)
        gradient_sum = gradient_sum.reshape((b_sz,) + self.size_of_input)
        return gradient_sum    

    def forward_feed(self, X, t=True):
        self.input_feed = X
        batch_sz, channel, hi, wi = X.shape
        X = X.reshape(batch_sz * channel, 1, hi, wi)
        _, height_output, width_output = self.return_out()
        input_cols = image_convert_2_column(X, self.pool_size, self.stride, self.type_of_padding)
        result_of_pooling = self._forward_pooling(input_cols)
        result_of_pooling = result_of_pooling.reshape(height_output, width_output, batch_sz, channel)
        result_of_pooling = result_of_pooling.transpose(2, 3, 0, 1)
        return result_of_pooling


    def return_out(self):
        channel, hi, wi = self.size_of_input
        width_output = (wi - self.pool_size[1]) // self.stride + 1
        height_output = (hi - self.pool_size[0]) // self.stride + 1
        return channel, int(height_output), int(width_output)

class MaximumPoolingLayer(PoolingLayer):
    def _backward_pooling(self, gradient_sum):
        total_gradcol = np.zeros((np.prod(self.pool_size), gradient_sum.size))
        indices_of_max_values = self.cache
        total_gradcol[indices_of_max_values, range(gradient_sum.size)] = gradient_sum
        return total_gradcol
       
    def _forward_pooling(self, X_col):
        indices_of_max_values = np.argmax(X_col, axis=0).flatten()
        o = X_col[indices_of_max_values, range(indices_of_max_values.size)]
        self.cache = indices_of_max_values
        return o

    
